import hyperId from 'hyperid';
import { AckPolicy, AckPolicyMap, Message } from '../grpc/generated/api_pb';
import { BuiltinPartitioners, PartitionerLike } from './partition';

export { AckPolicy } from '../grpc/generated/api_pb';

const envelopeCookie = Buffer.from('LIFT');
const envelopeCookieLength = envelopeCookie.length;

/**
 * Liftbridge message headers.
 * @category Message
 */
interface ILiftbridgeMessageHeader {
    [key: string]: string;
}

/**
 * Liftbridge message interface.
 * @category Message
 */
export interface ILiftbridgeMessage {
    /**
     * Message subject.
     */
    subject?: string;
    /**
     * Key to set on the Message. If Liftbridge has stream compaction enabled,
     * the stream will retain only the last value for each key.
     */
    key?: Uint8Array | string | null;
    /**
     * Value to set on the Message for the key.
     */
    value: Uint8Array | string;
    /**
     * Sets the identifier used to correlate an ack with the
     * published message.
     *
     * Defaults to a unique ID generated by [`hyperid`](https://github.com/mcollina/hyperid/blob/master/README.md).
     */
    correlationId?: string;
    /**
     * Key-value pairs to set on the Message headers map.
     */
    headers?: ILiftbridgeMessageHeader;
    /**
     * Sets the NATS subject Liftbridge should publish the message ack
     * to. If it's not set or if there's no Deadline, Liftbridge will not send an ack.
     */
    ackInbox?: string;
    /**
     * Controls the behavior of message acks sent by the server. By
     * default, Liftbridge will send an ack when the stream leader has written
     * the message to its write-ahead log.
     */
    ackPolicy?: AckPolicyMap[keyof AckPolicyMap];
    /**
     * Specifies the stream partition to publish the message to. If
     * this is set, any `partitioner` will not be used. This is a pointer to
     * allow distinguishing between undefined and 0.
     */
    partition?: number | undefined;
    /**
     * Specifies the strategy for mapping a message to a stream partition.
     *
     * Can be either a string (see [[BuiltinPartitioners]]) or a custom implementation
     * of [[BasePartitioner]].
     */
    partitionStrategy?: keyof BuiltinPartitioners | PartitionerLike | undefined;
}

/**
 * Liftbridge message subclass.
 *
 * Includes some helpful methods to convert to/from native JSON objects
 * to Liftbridge gRPC objects.
 *
 * @category Message
 */
export default class LiftbridgeMessage extends Message {
    /**
     * See [[ILiftbridgeMessage.correlationId]].
     */
    public correlationId = hyperId().uuid;

    /**
     * See [[ILiftbridgeMessage.partition]].
     */
    public partition: number | undefined = undefined;

    /**
     * See [[ILiftbridgeMessage.partitionStrategy]].
     */
    public partitionStrategy: keyof BuiltinPartitioners | PartitionerLike | undefined = 'key';

    /**
     * Creates a Message object that is a representation of the gRPC `Message` object.
     * @param message Message object.
     * @returns Message object (with some extra helpful methods).
     */
    constructor(message: ILiftbridgeMessage) {
        super();
        if (message.subject) this.setSubject(message.subject);
        this.setValue(typeof message.value === 'string' ? Buffer.from(message.value) : message.value);

        if (message.key) {
            this.setKey(typeof message.key === 'string' ? Buffer.from(message.key) : message.key);
        } else {
            this.setKey(Buffer.from(''));
        }

        if (message.partition) {
            this.partition = message.partition;
            this.partitionStrategy = undefined;
        } else {
            this.partitionStrategy = message.partitionStrategy;
            this.partition = undefined;
        }

        if (message.correlationId) this.setCorrelationid(message.correlationId);
        if (message.ackInbox) this.setAckinbox(message.ackInbox);
        if (!message.ackPolicy) this.setAckpolicy(AckPolicy.NONE);

        if (message.headers) {
            const headerKeys = Object.keys(message.headers);
            if (headerKeys.length) {
                headerKeys.forEach(headerKey => {
                    this.getHeadersMap().set(headerKey, Buffer.from((message.headers as ILiftbridgeMessageHeader)[headerKey], 'utf8'));
                });
            }
        }
    }

    /**
     * Create a serialized `Message` object with the Liftbridge envelope.
     *
     * ℹ️ Use only when you're talking directly to NATS systems.
     *
     * @returns Buffer of Protobuf message.
     */
    public serializeMessage(): Buffer {
        const serializedMessage = this.serializeBinary();
        return Buffer.concat([envelopeCookie, serializedMessage], envelopeCookieLength + serializedMessage.length);
    }

    /**
     * Returns a deserialized `Message` in JSON form.
     *
     * Buffers & byte-arrays are deserialized to UTF-8 strings,
     * and maps of the form [[k1, v1], [k2, v2]] are converted to
     * objects of the form { k1: v1, k2, v2 }.
     *
     * @param message Liftbridge `Message` to deserialize.
     * @returns JSON form of given `Message`.
     */
    public static toJSON(message: Message): ILiftbridgeMessage {
        const rawObject = message.toObject();
        const { headersMap, ...messageWithoutHeadersMap } = rawObject;
        return {
            ...messageWithoutHeadersMap,
            key: Buffer.from(rawObject.key.toString(), 'base64').toString('utf8'),
            value: Buffer.from(rawObject.value.toString(), 'base64').toString('utf8'),
            headers: rawObject.headersMap.reduce((k, v) => {
                const nk = { ...k };
                nk[v[0]] = typeof v[1] === 'string' ? v[1] : Buffer.from(v[1]).toString('utf8');
                return nk;
            }, {}),
        };
    }
}
